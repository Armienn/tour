Pakker, variabler, og funktioner.
Lær de grundlæggende komponenter af ethvert Go program.

The Go Authors
https://golang.org

* Pakker (packages)

Alle Go programmer er opbygget af pakker (packages).

Programmer starter med at køre i pakken `main`.

Dette program bruger pakkerne med importeringsstierne `"fmt"` and `"math/rand"`. 

Af konvention er pakkenavnet det samme som det sidste element af importeringsstien. For eksempel består pakken `"math/rand"` af filer, som begynder med erklæringen `package`rand`.

#appengine: *Note:* miljøet de her programmer kører i er deterministisk,
#appengine: so hver gang du kører eksempelprogrammet vil `rand.Intn`
#appengine: returnere det samme tal.
#appengine:
#appengine: (For at se et andet tal, `seed` tal generatoren; se [[https://golang.org/pkg/math/rand/#Seed][`rand.Seed`]].)

.play basics/packages.go

* Importeringer

Den her kode grupperer importeringer in i en parenteriseret, "faktoreret" `import` erklæring.

Man kan også skrive adskillige importerings erklæringer, sådan:

	import "fmt"
	import "math"

Men det er god programmeringsstil at bruge den faktorerede `import` erklæring.

.play basics/imports.go

* Eksporterede navne

I Go bliver et navn eksporteret hvis det begynder med et stort bogstav.
For eksempel, `Pizza` er et eksporteret navn, ligesom `Pi`, hvilket er
eksporteret fra `math` pakken.

`pizza` og `pi` starter ikke med et stort bogstav, så de bliver ikke eksporteret.

Når man importerer en pakke, kan man kun referere til dens eksporterede navne.
Alle "ueksporterede" navne kan ikke tilgås udenfor pakken, kun inde i.

Kør koden. Læg mærke til fejlbeskeden.

Ret `math.pi` til `math.Pi` for at fikse fejlen, og prøv igen.

.play basics/exported-names.go

* Funktioner

En funktion kan tage nul eller flere argumenter.

I det her eksempel tager `add` to parametre af typen `int`. 

Læg mærke til at typen kommer _efter_ navnet på variablen.

(For mere omkring hvorfor typer ser ud som de gør, se [[https://blog.golang.org/gos-declaration-syntax][artiklen om Go's deklarationssyntaks]].)

.play basics/functions.go

* Funktioner fortsat

Når to eller flere funktionsparametre i træk har samme type, kan man undlade typen fra alle bortset fra den sidste.

I det her eksempel har vi forkortet

	x int, y int

til

	x, y int

.play basics/functions-continued.go

* Adskillige resultater

En funktion kan returnere et vilkårligt antal resultater.

`swap` funktionen returnerer to "strings" (tekst-stykker).

.play basics/multiple-results.go

* Navngivne returneringsværdier

Go's returneringsværdier kan navngives. Hvis de navngives, bliver de håndteret som variabler defineret i toppen af funktionen.

Disse navne burde bruges til at dokumentere meningen af returneringsværdierne.

En `return` erklæring uden argumenter returnerer de navngivne returneringsværdier. Dette er kendt som en "naked return". 

"Naked return" erklæringer burde kun bruges i korte funktioner, som med eksemplet vist her. De kan skade læseligheden i længere funktioner.

.play basics/named-results.go

* Variabler

`var` erklæringen deklarerer en liste af variabler; ligesom med lister af funktionsargumenter er typen til sidst.

En `var` erklæring kan være på enten pakke eller funktionsniveauet. Vi kan se begge i det her eksempel.

.play basics/variables.go

* Variabler mew initialiseringer

En var deklaration kan inkludere initialiseringer, en per variabel.

Hvis der er en initialisering kan typen blive udeladt; variablen får automatisk typen baseret på initialiseringen. 

.play basics/variables-with-initializers.go

* Korte variabel deklarationer

Inde i en funktion kan den korte `:=` "assignment" erklæring blive brugt i stedet for en `var` deklaration med implicit type.  

Uden for en funktion skal alle erklæringer starte med et nøgleord (`var`, `func`, og så videre) og `:=` er ikke tilgængelig.  

.play basics/short-variable-declarations.go

* Grundlæggende typer

Go's grundlæggende typer er

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // alias for uint8

	rune // alias for int32
	     // repræsenterer et "Unicode code point"

	float32 float64

	complex64 complex128

Eksemplet viser variabler af flere typer,
og også at variabel deklarationer kan blive "faktoreret" ind i blokke,
ligesom med `import` erklæringer.

`int`, `uint`, og `uintptr` typerne er normalt 32 bits lange på 32-bit systemer og 64 bit lange på 64-bit systemer.
Når du har brug for en helttalsværdi burde du bruge `int`, medmindre du har en specifik grund til at bruge en bestemt størrelse af heltalstype.

.play basics/basic-types.go

* Nulværdier

Variabler deklareret uden en eksplicit startværdi bliver givet deres
_nulværdi_.

Nulværdien er:

- `0` for numeriske typer,
- `false` for den logiske (boolean) type, og
- `""` (den tomme string (tekst)) for strings.

.play basics/zero.go

* Type konverteringer

Udtrykket `T(v)` konverterer værdien `v` til typen `T`.

Nogle numeriske konverteringer:

	var i int = 42
	var f float64 = float64(i)
	var u uint = uint(f)

Eller, opsat simplere:

	i := 42
	f := float64(i)
	u := uint(f)

I Go kræver det en eksplicit konversion for at give en variabel af en type værdien fra en anden type, ulig i C.
Prøv at fjerne `float64` eller `uint` konverteringerne i eksemplet og se hvad der sker.

.play basics/type-conversions.go

* Type inference

When declaring a variable without specifying an explicit type (either by using the `:=` syntax or `var`=` expression syntax), the variable's type is inferred from the value on the right hand side.

When the right hand side of the declaration is typed, the new variable is of that same type:

	var i int
	j := i // j is an int

But when the right hand side contains an untyped numeric constant, the new variable may be an `int`, `float64`, or `complex128` depending on the precision of the constant:

	i := 42           // int
	f := 3.142        // float64
	g := 0.867 + 0.5i // complex128

Try changing the initial value of `v` in the example code and observe how its type is affected.

.play basics/type-inference.go

* Constants

Constants are declared like variables, but with the `const` keyword.

Constants can be character, string, boolean, or numeric values.

Constants cannot be declared using the `:=` syntax.

.play basics/constants.go

* Numeric Constants

Numeric constants are high-precision _values_.

An untyped constant takes the type needed by its context.

Try printing `needInt(Big)` too.

(An `int` can store at maximum a 64-bit integer, and sometimes less.)

.play basics/numeric-constants.go

* Congratulations!

You finished this lesson!

You can go back to the list of [[/list][modules]] to find what to learn next, or continue with the [[javascript:click('.next-page')][next lesson]].
